<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Rust 基础入门（已完结） | EmotionalEDM</title><meta name="author" content="EmotionalEDM"><meta name="copyright" content="EmotionalEDM"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="本文为阅读《Rust圣经》的笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust 基础入门（已完结）">
<meta property="og:url" content="http://emotionaledm.github.io/2025/12/01/Rust%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="EmotionalEDM">
<meta property="og:description" content="本文为阅读《Rust圣经》的笔记">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://www.imageoss.com/images/2025/12/02/Illustration-178803c2c8d45f3227d5.png">
<meta property="article:published_time" content="2025-11-30T16:00:00.000Z">
<meta property="article:modified_time" content="2025-12-13T15:49:31.678Z">
<meta property="article:author" content="EmotionalEDM">
<meta property="article:tag" content="Rust">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.imageoss.com/images/2025/12/02/Illustration-178803c2c8d45f3227d5.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Rust 基础入门（已完结）",
  "url": "http://emotionaledm.github.io/2025/12/01/Rust%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/",
  "image": "https://www.imageoss.com/images/2025/12/02/Illustration-178803c2c8d45f3227d5.png",
  "datePublished": "2025-11-30T16:00:00.000Z",
  "dateModified": "2025-12-13T15:49:31.678Z",
  "author": [
    {
      "@type": "Person",
      "name": "EmotionalEDM",
      "url": "http://emotionaledm.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="https://www.imageoss.com/images/2025/08/31/_2025-08-31_154628_5697ba1eb627e156b0e.jpg"><link rel="canonical" href="http://emotionaledm.github.io/2025/12/01/Rust%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: undefined,
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Rust 基础入门（已完结）',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://www.imageoss.com/images/2025/08/31/_2025-08-31_154628_5697ba1eb627e156b0e.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/video/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://www.imageoss.com/images/2025/12/02/Illustration-178803c2c8d45f3227d5.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">EmotionalEDM</span></a><a class="nav-page-title" href="/"><span class="site-name">Rust 基础入门（已完结）</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/video/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Rust 基础入门（已完结）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-11-30T16:00:00.000Z" title="Created 2025-12-01 00:00:00">2025-12-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-12-13T15:49:31.678Z" title="Updated 2025-12-13 23:49:31">2025-12-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><em><strong>本文为阅读《Rust圣经》的第一篇笔记，内容包括《Rust基础入门》前4章节，后续章节请移步到本网站文章《Rust基础入门：续章》等，如果想查看原书请搜索“Rust圣经”或点击此链接：[Rust语言圣经(Rust Course)](<a target="_blank" rel="noopener" href="https://course.rs/about-book.html">https://course.rs/about-book.html</a>)</strong></em></p>
<hr>
<h1 id="变量绑定与解构"><a href="#变量绑定与解构" class="headerlink" title="变量绑定与解构"></a>变量绑定与解构</h1><h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><p>Rust语言变量命名不能和关键字重复</p>
<h2 id="变量绑定"><a href="#变量绑定" class="headerlink" title="变量绑定"></a>变量绑定</h2><p>将一个值绑定给一个变量，类似赋值但不完全是赋值，要注意“所有权”这个概念。</p>
<h2 id="变量可变性"><a href="#变量可变性" class="headerlink" title="变量可变性"></a>变量可变性</h2><p>Rust变量默认情况下不可变：</p>
<ul>
<li><p>不可变变量：</p>
<pre><code class="language-rust">let x = 5;
//此时不能再对x赋值，若有代码“x = 6;”则会报错
</code></pre>
</li>
<li><p>可变变量：</p>
<pre><code class="language-rust">let mut x = 5;
//可以对x进行再赋值
</code></pre>
</li>
</ul>
<h2 id="未使用的变量"><a href="#未使用的变量" class="headerlink" title="未使用的变量"></a>未使用的变量</h2><p>如果未使用的变量开头不是下划线，则会引发warning</p>
<p>避免方法：</p>
<ul>
<li><p>变量开头使用下划线</p>
</li>
<li><p>使用 #![allow(unused)] 属性，例如：</p>
<pre><code class="language-rust">#![allow(unused)]
fn main() &#123;
    let x = 1;
&#125;
</code></pre>
</li>
</ul>
<h2 id="变量解构"><a href="#变量解构" class="headerlink" title="变量解构"></a>变量解构</h2><pre><code class="language-rust">let (a, mut b): (bool,bool) = (true, false);
</code></pre>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><pre><code class="language-rust">const MAX_POINTS: u32 = 100_000;
</code></pre>
<h2 id="变量遮蔽"><a href="#变量遮蔽" class="headerlink" title="变量遮蔽"></a>变量遮蔽</h2><pre><code class="language-rust">fn main() &#123;
    let x = 5;
    /* x = 5 */
    let x = x + 1;// 这句话在main函数的作用域内对之前的x进行遮蔽
	/* x = 6 */
    &#123;
        let x = x * 2;// 这句话在当前的花括号作用域内，对之前的x进行遮蔽
        /* x = 12 */
    &#125;
	/* x = 6 */
&#125;
</code></pre>
<p>注意：使用变量遮蔽（let）可以改变变量的数据类型，但是不用let对可变变量进行不同类型的赋值是不允许的</p>
<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><ul>
<li>数值类型：有符号整数 (i8, i16, i32, i64, isize)、 无符号整数 (u8, u16, u32, u64, usize) 、浮点数 (f32, f64)、以及有理数、复数</li>
<li>字符串：字符串字面量和字符串切片 &amp;str</li>
<li>布尔类型：true 和 false</li>
<li>字符类型：表示单个 Unicode 字符，存储为 4 个字节</li>
<li>单元类型：即 () ，其唯一的值也是 ()</li>
</ul>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>语句完成了一个具体的操作，但是并没有返回值。语句一定以“;”结尾。</p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式会进行求值，然后返回一个值。表达式结尾不会有“;”。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Rust 的函数体是由一系列语句组成，最后由一个表达式来返回值</p>
<pre><code class="language-rust">fn add_with_extra(x: i32, y: i32) -&gt; i32 &#123;
    let x = x + 1; // 语句
    let y = y + 5; // 语句
    x + y // 表达式
&#125;
//或者使用return
fn plus_or_minus(x:i32) -&gt; i32 &#123;
    if x &gt; 5 &#123;
        return x - 5
    &#125;
    x + 5
&#125;
</code></pre>
<p><img src="/img/Rust%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.assets/1.png"></p>
<p>当用 ! 作函数返回类型的时候，表示该函数永不返回( diverging functions )，特别的，这种语法往往用做会导致程序崩溃的函数：</p>
<pre><code class="language-rust">fn dead_end() -&gt; ! &#123;
    panic!(&quot;你已经到了穷途末路，崩溃吧！&quot;);
&#125;
</code></pre>
<p>与函数有所区别的是宏调用，例如 println! 是宏调用，看起来像是函数但是它返回的是宏定义的代码块。常见宏调用如下：</p>
<pre><code class="language-rust">println!(&quot;a + b = &#123;&#125;&quot;, c); // 打印
/* Rust 使用 &#123;&#125; 来作为格式化输出占位符， println! 会自动推导出具体的类型。 */

panic!(&quot;崩溃吧！&quot;); // 触发不可恢复错误
/* 原理：首先打印panic消息和位置信息（如果设置了环境变量RUST_BACKTRACE=1，还会打印回溯信息）。
   然后程序开始栈展开（stack unwinding），这会清理每个函数调用中的数据（调用析构函数等）。
   最后，程序终止。 */

assert_eq!(a, b); // 比较
/* 如果a, b相等，则编译通过，否则程序panic并打印错误信息，一般在测试时使用。 */

dbg!(new_string); //返回其内表达式的值
</code></pre>
<h1 id="所有权和借用"><a href="#所有权和借用" class="headerlink" title="所有权和借用"></a>所有权和借用</h1><h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈按照顺序存储值并以相反顺序取出值，这也被称作后进先出。增加数据叫做进栈，移出数据则叫做出栈。</p>
<p>因为上述的实现方式，栈中的所有数据都必须占用已知且固定大小的内存空间，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在堆上。当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的指针，该过程被称为在堆上分配内存，有时简称为 “分配”(allocating)。</p>
<p>接着，该指针会被推入栈中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的指针，来获取数据在堆上的实际内存位置，进而访问该数据。</p>
<h2 id="所有权原则"><a href="#所有权原则" class="headerlink" title="所有权原则"></a>所有权原则</h2><p>所有权的规则：</p>
<ul>
<li>Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者</li>
<li>一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者</li>
<li>当所有者（变量）离开作用域范围时，这个值将被丢弃(drop)</li>
</ul>
<p>Rust语言的变量作用域和C等其他语言没有区别，例如：</p>
<pre><code class="language-rust">&#123;                      // s 在这里无效，它尚未声明
    let s = &quot;hello&quot;;   // 从此处起，s 是有效的
    // 使用 s
&#125;                      // 此作用域已结束，s不再有效
</code></pre>
<h2 id="初识String"><a href="#初识String" class="headerlink" title="初识String"></a>初识String</h2><p>Rust 为我们提供动态字符串类型: String，该类型被分配到堆上，因此可以动态伸缩，也就能存储在编译时大小未知的文本。</p>
<p>String 的用法如下：</p>
<pre><code class="language-rust">let mut s = String::from(&quot;hello&quot;);
s.push_str(&quot;, world!&quot;); // push_str() 在字符串后追加字面值
println!(&quot;&#123;&#125;&quot;, s); // 将打印 `hello, world!`
</code></pre>
<p>注：String 不是基本类型，String 类型包含了堆指针、字符串长度、字符串容量等多个复杂内容。</p>
<h2 id="变量绑定后的数据交互"><a href="#变量绑定后的数据交互" class="headerlink" title="变量绑定后的数据交互"></a>变量绑定后的数据交互</h2><ul>
<li><p>转移所有权：将一个值的所有权进行转移，原变量名会失去这个值的所有权。</p>
<pre><code class="language-rust">let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
</code></pre>
<p>此例中，s1将会失去”hello”的所有权，运行</p>
<pre><code class="language-rust">println!(&quot;&#123;&#125;, world!&quot;, s1);
</code></pre>
<p>会报错。</p>
</li>
<li><p>深拷贝：clone，性能比较低，是在堆的基础上的拷贝。</p>
<pre><code class="language-rust">let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();
</code></pre>
<p>此例中s1，s2都会拥有”hello”的所有权（但是是两个不同的”hello”）。</p>
<p>Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何自动的复制都不是深拷贝。</p>
</li>
<li><p>浅拷贝：浅拷贝只发生在栈上，因此性能很高。</p>
<pre><code class="language-rust">let x = 5;
let y = x;
</code></pre>
<p>此例中x和y都会赋值为5.这种可以进行直接浅拷贝的变量类型所拥有的特征叫做Copy特征。</p>
<p>任何基本类型的组合可以 Copy ，不需要分配内存或某种形式资源的类型是可以 Copy 的。</p>
</li>
</ul>
<h2 id="函数的传值与返回"><a href="#函数的传值与返回" class="headerlink" title="函数的传值与返回"></a>函数的传值与返回</h2><pre><code class="language-rust">fn main() &#123;
    let s = String::from(&quot;hello&quot;);  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x

&#125; // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) &#123; // some_string 进入作用域
    println!(&quot;&#123;&#125;&quot;, some_string);
&#125; // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) &#123; // some_integer 进入作用域
    println!(&quot;&#123;&#125;&quot;, some_integer);
&#125; // 这里，some_integer 移出作用域。不会有特殊操作
</code></pre>
<p>上述例子中，在  takes_ownership(s); 之后运行 println!(“{}”,s); 将会报错，因为s的”hello”所有权已经转移给some_string。但是i32型的变量是Copy的，所以在 makes_copy(x); 后运行 println!(“{}”,x); 是不会报错的。</p>
<pre><code class="language-rust">fn main() &#123;
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 移给 s1

    let s2 = String::from(&quot;hello&quot;);     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到
                                        // takes_and_gives_back 中,
                                        // 它也将返回值移给 s3
&#125; // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
  // 所以什么也不会发生。s1 移出作用域并被丢弃

fn gives_ownership() -&gt; String &#123;             // gives_ownership 将返回值移动给
                                             // 调用它的函数

    let some_string = String::from(&quot;hello&quot;); // some_string 进入作用域.

    some_string                              // 返回 some_string 并移出给调用的函数
&#125;

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -&gt; String &#123; // a_string 进入作用域

    a_string  // 返回 a_string 并移出给调用的函数
&#125;
</code></pre>
<p>同理，在 main() 函数最后， s1，s3 可以被打印， s2 不可被打印。</p>
<h2 id="引用和借用"><a href="#引用和借用" class="headerlink" title="引用和借用"></a>引用和借用</h2><h3 id="引用与解引用"><a href="#引用与解引用" class="headerlink" title="引用与解引用"></a>引用与解引用</h3><ul>
<li><p>引用（名词）：常规引用是一个指针类型，指向了对象存储的内存地址。</p>
</li>
<li><p>解引用（名词）：解出引用所指向的值，即引用对象存储的值</p>
</li>
<li><p>借用（动词）：获取变量的引用，称之为借用</p>
</li>
<li><p>引用的作用域：从引用创建开始到最后一次使用的位置（旧版 Rust 的引用的作用域等于变量作用域）。对于这种编译器优化行为，Rust 专门起了一个名字 —— Non-Lexical Lifetimes(NLL)，专门用于找到某个引用在作用域(})结束前就不再被使用的代码位置。</p>
</li>
<li><p>例子：</p>
<pre><code class="language-rust">fn main() &#123;
    let x = 5;
    let y = &amp;x; // y 为引用
    assert_eq!(5, x); // x 对 5 的所有权并没有消失
    assert_eq!(5, *y); // *y 为解引用
&#125;
</code></pre>
</li>
</ul>
<h3 id="不可变引用与可变引用"><a href="#不可变引用与可变引用" class="headerlink" title="不可变引用与可变引用"></a>不可变引用与可变引用</h3><ul>
<li><p>不可变引用：变量默认不可变，所以引用指向的值也默认不可变。示例：</p>
<pre><code class="language-rust">fn main() &#123;
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;The length of &#39;&#123;&#125;&#39; is &#123;&#125;.&quot;, s1, len);
&#125;

fn calculate_length(s: &amp;String) -&gt; usize &#123;
    s.len()
&#125;
</code></pre>
<p>这里的 &amp; 就是引用，这样传入引用的函数可以维持 s1 的 “hello” 所有权，不需要复杂地在函数中传入传出所有权。但是不能通过这个引用修改 s1 的值，原因： s1 是不可变变量，引用也不可变。</p>
<p>下为引用示意图：<img src="/img/Rust%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.assets/2.jpg"></p>
</li>
<li><p>可变引用：对可变变量的引用。</p>
<pre><code class="language-rust">fn main() &#123;
    let mut s = String::from(&quot;hello&quot;); // 可变
    change(&amp;mut s); // 可变
&#125;

fn change(some_string: &amp;mut String) &#123;
    some_string.push_str(&quot;, world&quot;); // push_str 是在目标字符串后添加字符串的函数
&#125;
</code></pre>
<p>这样运行就不会报错了。</p>
<p>可变引用有两个很大限制：</p>
<ul>
<li>同一作用域，特定数据只能有一个可变引用</li>
<li>可变引用与不可变引用不能同时存在</li>
</ul>
</li>
</ul>
<h3 id="悬垂引用"><a href="#悬垂引用" class="headerlink" title="悬垂引用"></a>悬垂引用</h3><p>悬垂引用：悬垂引用也叫做悬垂指针，意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。Rust语言不允许悬垂指针的出现。</p>
<pre><code class="language-rust">fn main() &#123;
    let reference_to_nothing = dangle();
&#125;

fn dangle() -&gt; &amp;String &#123; // dangle 返回一个字符串的引用

    let s = String::from(&quot;hello&quot;); // s 是一个新字符串

    &amp;s // 返回字符串 s 的引用
&#125; // 这里 s 离开作用域并被丢弃。其内存被释放。
  // 危险！
// 上述代码运行会报错。
</code></pre>
<h1 id="复合类型（一）：字符串和数组"><a href="#复合类型（一）：字符串和数组" class="headerlink" title="复合类型（一）：字符串和数组"></a>复合类型（一）：字符串和数组</h1><h2 id="字符串与切片"><a href="#字符串与切片" class="headerlink" title="字符串与切片"></a>字符串与切片</h2><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><ul>
<li><p>对于字符串而言，切片就是对String类型中某一部分的引用，语法如下：</p>
<pre><code class="language-rust">let s = String::from(&quot;hello world&quot;);

let hello = &amp;s[0..5];     // 左闭右开
let world = &amp;s[6..11];    // 左闭右开
</code></pre>
<p>示意图如下：<img src="/img/Rust%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.assets/3.jpg"></p>
</li>
<li><p>Rust 语言的 <code>..</code> range序列与 Python 的类似，可以在索引 0 处省略 0 ，索引 len 处省略 len：</p>
<pre><code class="language-rust">let slice = &amp;s[0..2];
let slice = &amp;s[..2];
let slice = &amp;s[4..len];
let slice = &amp;s[4..];
let slice = &amp;s[0..len];
let slice = &amp;s[..];
</code></pre>
</li>
<li><p>切片索引必须在字符边界位置，这一点在UTF-8等编码的字符处理时要注意。以UTF-8为例，如果要切片纯UTF-8的中文字符串，必须满足切片的两个索引都为3的倍数（中文在 UTF-8 中占用三个字节）。</p>
</li>
<li><p>字符串切片的类型标识是 &amp;str</p>
</li>
<li><p>因为切片是对集合的部分引用，因此不仅仅字符串有切片，其它集合类型也有，例如数组。</p>
</li>
<li><p>字符串的字面量是切片：</p>
<pre><code class="language-rust">let s = &quot;Hello, world!&quot;;     // s 的类型是 &amp;str
/* 下面这个语句和上面等效 */
let s: &amp;str = &quot;Hello, world!&quot;;
</code></pre>
<p>s 这个切片指向了程序可执行文件中的某个点，这也是为什么字符串字面量是不可变的，因为 &amp;str 是一个不可变引用。</p>
</li>
<li><p>简单总结下切片的特点：<em>（ps：如果这里没有看懂可以先跳过，等学完“数组——数组切片”后或许能更好地理解）</em></p>
<ul>
<li>切片的长度在运行时确定，并非固定不变，而是取决于创建时指定的起始和结束位置，提供了灵活的数据访问视图</li>
<li>切片本身不拥有底层数据，它只是对原始数据（如数组、String或 &amp;str）的一个“视图”或引用。因此创建切片的代价很小，避免了不必要的数据复制</li>
<li>切片类型 [T] 和 str 本身是动态大小类型（DST），其大小在编译时无法确定。而更常用的切片引用类型 &amp;[T]和 &amp;str是胖指针，包含指向数据的指针和长度信息，具有固定的大小（在64位系统上通常为16字节），这使其能够满足Rust对固定大小数据类型的要求，因此更为实用</li>
<li>Rust的借用检查器会确保切片的生命周期不会超过其引用的底层数据，从而在提供灵活性的同时保证了内存安全</li>
</ul>
</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li><p>Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)</p>
</li>
<li><p>Rust 在语言级别，只有一种字符串类型： str，它通常是以引用类型出现 &amp;str，也就是上文提到的字符串切片。虽然语言级别只有上述的 str 类型，但是在标准库里，还有多种不同用途的字符串类型，其中使用最广的即是 String类型。</p>
</li>
<li><p>str 类型是硬编码进可执行文件，也无法被修改，但是 String 则是一个可增长、可改变且具有所有权的 UTF-8 编码字符串，当 Rust 用户提到字符串时，往往指的就是 String 类型和 &amp;str 字符串切片类型，这两个类型都是 UTF-8 编码。</p>
</li>
<li><p>String 与 &amp;str 的转换：</p>
<pre><code class="language-rust">/* &amp;str -&gt; String */
let s = String::from(&quot;hello,world&quot;)
let s = &quot;hello,world&quot;.to_string()  // to_string 将值转换为其字符串表示形式

/* String -&gt; &amp;str */
fn main() &#123;
    let s = String::from(&quot;hello,world!&quot;);
    say_hello(&amp;s);
    say_hello(&amp;s[..]);
    say_hello(s.as_str());  // as_str 获取该字符串的一个不可变切片引用（&amp;str）
&#125;

fn say_hello(s: &amp;str) &#123;
    println!(&quot;&#123;&#125;&quot;,s);
&#125;
</code></pre>
</li>
<li><p>Rust <strong>不允许</strong>使用索引的方式访问字符串的某个字符或者子串。通过索引区间来访问字符串时，需要格外的小心。</p>
</li>
</ul>
<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><p>由于 String 是可变字符串，下面介绍 Rust 字符串的修改，添加，删除等常用方法：</p>
<ul>
<li><p>追加（Push）</p>
<pre><code class="language-rust">fn main() &#123;
    let mut s = String::from(&quot;Hello &quot;);

    s.push_str(&quot;rust&quot;);  //追加字符串字面量
    println!(&quot;追加字符串 push_str() -&gt; &#123;&#125;&quot;, s);

    s.push(&#39;!&#39;);  //追加字符 char
    println!(&quot;追加字符 push() -&gt; &#123;&#125;&quot;, s);
&#125;
</code></pre>
<p>代码运行结果：</p>
<pre><code class="language-bash">追加字符串 push_str() -&gt; Hello rust
追加字符 push() -&gt; Hello rust!
</code></pre>
</li>
<li><p>插入（Insert）</p>
<pre><code class="language-rust">fn main() &#123;
    let mut s = String::from(&quot;Hello rust!&quot;);
    s.insert(5, &#39;,&#39;);  // 插入单个字符 char
    println!(&quot;插入字符 insert() -&gt; &#123;&#125;&quot;, s);
    s.insert_str(6, &quot; I like&quot;);  // 插入字符串字面量
    println!(&quot;插入字符串 insert_str() -&gt; &#123;&#125;&quot;, s);
&#125;  // insert 的第一个参数实质上是字节偏移量，而不是字符序号。
</code></pre>
<p>代码运行结果：</p>
<pre><code class="language-bash">插入字符 insert() -&gt; Hello, rust!
插入字符串 insert_str() -&gt; Hello, I like rust!
</code></pre>
</li>
<li><p>替换（Replace）</p>
<ul>
<li><p>replace，可适用于 String 和 &amp;str 类型</p>
<pre><code class="language-rust">fn main() &#123;
    let string_replace = String::from(&quot;I like rust. Learning rust is my favorite!&quot;);
    let new_string_replace = string_replace.replace(&quot;rust&quot;, &quot;RUST&quot;);  // replace 会返回一个新字符串，而不是直接在原字符串上进行修改。
    dbg!(new_string_replace);
&#125;
</code></pre>
<p>代码运行结果：</p>
<pre><code class="language-bash">new_string_replace = &quot;I like RUST. Learning RUST is my favorite!&quot;
</code></pre>
</li>
<li><p>replacen，可适用于 String 和 &amp;str 类型</p>
<pre><code class="language-rust">fn main() &#123;
    let string_replace = &quot;I like rust. Learning rust is my favorite!&quot;;
    let new_string_replacen = string_replace.replacen(&quot;rust&quot;, &quot;RUST&quot;, 1);  // 第三个参数指的是替换的个数，从头开始数。
    dbg!(new_string_replacen);
&#125;
</code></pre>
<p>代码运行结果：</p>
<pre><code class="language-bash">new_string_replacen = &quot;I like RUST. Learning rust is my favorite!&quot;
</code></pre>
</li>
<li><p>replace_range，仅适用于 String 类型</p>
<pre><code class="language-rust">fn main() &#123;
    let mut string_replace_range = String::from(&quot;I like rust!&quot;);
    string_replace_range.replace_range(7..8, &quot;R&quot;);  // 直接操作原来的字符串，不会返回新字符串。第二个参数要是字符串。
    dbg!(string_replace_range);
&#125;
</code></pre>
<p>代码运行结果：</p>
<pre><code class="language-bash">string_replace_range = &quot;I like Rust!&quot;
</code></pre>
</li>
</ul>
</li>
<li><p>删除（Delete）</p>
<p>下列相关方法仅适用于 String ，因为都是直接操作原来的字符串。</p>
<ul>
<li><p>pop —— 删除并返回字符串的最后一个字符</p>
<p>其返回值是一个 Option 类型，为删除掉的字符（ Option 类型的特点：如果字符串为空，则返回 None）。</p>
<pre><code class="language-rust">fn main() &#123;
    let mut string_pop = String::from(&quot;rust pop 中文!&quot;);
    let p1 = string_pop.pop();
    let p2 = string_pop.pop();
    dbg!(p1);
    dbg!(p2);
    dbg!(string_pop);
&#125;
</code></pre>
<p>代码运行结果：</p>
<pre><code class="language-bash">p1 = Some(
   &#39;!&#39;,
)
p2 = Some(
   &#39;文&#39;,
)
string_pop = &quot;rust pop 中&quot;
</code></pre>
</li>
<li><p>remove —— 删除并返回字符串中指定位置的字符</p>
<p>其返回值为删除位置的字符串。remove() 方法是按照字节来处理字符串的，如果参数所给的位置不是合法的字符边界，则会发生错误。</p>
<pre><code class="language-rust">fn main() &#123;
    let mut string_remove = String::from(&quot;测试remove方法&quot;);
    println!(
        &quot;string_remove 占 &#123;&#125; 个字节&quot;,
        std::mem::size_of_val(string_remove.as_str())
    );
    // 删除第一个汉字
    string_remove.remove(0);
    // 下面代码会发生错误
    // string_remove.remove(1);
    // 直接删除第二个汉字
    // string_remove.remove(3);
    dbg!(string_remove);
&#125;
</code></pre>
<p>代码运行结果：</p>
<pre><code class="language-bash">string_remove 占 18 个字节
string_remove = &quot;试remove方法&quot;
</code></pre>
</li>
<li><p>truncate —— 删除字符串中从指定位置开始到结尾的全部字符</p>
<p>无返回值，它同样是按照字节来处理字符串的，如果参数所给的位置不是合法的字符边界，则会发生错误。</p>
<pre><code class="language-rust">fn main() &#123;
    let mut string_truncate = String::from(&quot;测试truncate&quot;);
    string_truncate.truncate(3);
    dbg!(string_truncate);
&#125;
</code></pre>
<p>代码运行结果：</p>
<pre><code class="language-bash">string_truncate = &quot;测&quot;
</code></pre>
</li>
<li><p>clear —— 清空字符串</p>
<p>相当于 truncate() 方法参数为 0 的时候</p>
<pre><code class="language-rust">fn main() &#123;
    let mut string_clear = String::from(&quot;string clear&quot;);
    string_clear.clear();
    dbg!(string_clear);
&#125;
</code></pre>
<p>代码运行结果：</p>
<pre><code class="language-bash">string_clear = &quot;&quot;
</code></pre>
</li>
</ul>
</li>
<li><p>连接（Concatenate）</p>
<ul>
<li><p>使用 <code>+</code> 或者 <code>+=</code> 连接字符串</p>
<p>使用 + 或者 +&#x3D; 连接字符串，要求右边的参数必须为字符串的切片引用（Slice）类型。其实当调用 + 的操作符时，相当于调用了 std::string 标准库中的 add() 方法，这里 add() 方法的第二个参数是一个引用的类型。因此我们在使用 + 时， 必须传递切片引用类型。不能直接传递 String 类型。+ 是返回一个新的字符串，所以变量声明可以不需要 mut 关键字修饰。</p>
<pre><code class="language-rust">fn main() &#123;
    let string_append = String::from(&quot;hello &quot;);
    let string_rust = String::from(&quot;rust&quot;);
    // &amp;string_rust会自动解引用为&amp;str
    let result = string_append + &amp;string_rust;
    let mut result = result + &quot;!&quot;; // `result + &quot;!&quot;` 中的 `result` 是不可变的
    result += &quot;!!!&quot;;

    println!(&quot;连接字符串 + -&gt; &#123;&#125;&quot;, result);
    // 以下代码去掉注释后会报错，因为 + 实际上是调用了 add() 方法，所有权被转移到 add() 方法里面， add() 方法调用后就被释放了，同时 string_append 也被释放了。再使用 string_append 就会发生错误。
    // println!(&quot;原字符串: &#123;&#125;&quot;, string_append);
&#125;
</code></pre>
<p>代码运行结果：</p>
<pre><code class="language-bash">连接字符串 + -&gt; hello rust!!!!
</code></pre>
</li>
<li><p>format! 宏</p>
</li>
</ul>
<p>  format! 这种方式适用于 String 和 &amp;str 。format! 的用法与 print! 的用法类似，它会将格式化文本输出到 <code>String</code> 字符串。</p>
<pre><code class="language-rust">fn main() &#123;
    let s1 = &quot;hello&quot;;
    let s2 = String::from(&quot;rust&quot;);
    let s = format!(&quot;&#123;&#125; &#123;&#125;!&quot;, s1, s2);
    println!(&quot;&#123;&#125;&quot;, s);
&#125;
</code></pre>
<p>  代码运行结果</p>
<pre><code class="language-bash">hello rust!
</code></pre>
</li>
</ul>
<h3 id="字符串转义"><a href="#字符串转义" class="headerlink" title="字符串转义"></a>字符串转义</h3><p>我们可以通过转义的方式 \ 输出 ASCII 和 Unicode 字符。</p>
<pre><code class="language-rust">fn main() &#123;
    // 通过 \ + 字符的十六进制表示，转义输出一个字符
    let byte_escape = &quot;I&#39;m writing \x52\x75\x73\x74!&quot;;
    println!(&quot;What are you doing\x3F (\\x3F means ?) &#123;&#125;&quot;, byte_escape);

    // \u 可以输出一个 unicode 字符
    let unicode_codepoint = &quot;\u&#123;211D&#125;&quot;;
    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;

    println!(
        &quot;Unicode character &#123;&#125; (U+211D) is called &#123;&#125;&quot;,
        unicode_codepoint, character_name
    );

    // 换行了也会保持之前的字符串格式
    // 使用\忽略换行符
    let long_string = &quot;String literals
                        can span multiple lines.
                        The linebreak and indentation here -&gt;\
                        &lt;- can be escaped too!&quot;;
    println!(&quot;&#123;&#125;&quot;, long_string);
&#125;
</code></pre>
<p>当然，在某些情况下，可能你会希望保持字符串的原样，不要转义：</p>
<pre><code class="language-rust">fn main() &#123;
    println!(&quot;&#123;&#125;&quot;, &quot;hello \\x52\\x75\\x73\\x74&quot;);
    let raw_str = r&quot;Escapes don&#39;t work here: \x3F \u&#123;211D&#125;&quot;;
    println!(&quot;&#123;&#125;&quot;, raw_str);

    // 如果字符串包含双引号，可以在开头和结尾加 #
    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;
    println!(&quot;&#123;&#125;&quot;, quotes);

    // 如果字符串中包含 # 号，可以在开头和结尾加多个 # 号，最多加255个，只需保证与字符串中连续 # 号的个数不超过开头和结尾的 # 号的个数即可
    let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;
    println!(&quot;&#123;&#125;&quot;, longer_delimiter);
&#125;
</code></pre>
<h3 id="操作-UTF-8-字符串"><a href="#操作-UTF-8-字符串" class="headerlink" title="操作 UTF-8 字符串"></a>操作 UTF-8 字符串</h3><p>如果想要以 Unicode 字符的方式遍历字符串，最好的办法是使用 chars 方法，例如：</p>
<pre><code class="language-rust">for c in &quot;中国人&quot;.chars() &#123;
    println!(&quot;&#123;&#125;&quot;, c);
&#125;
</code></pre>
<p>输出如下：</p>
<pre><code class="language-bash">中
国
人
</code></pre>
<p>如果想要获取底层字节数组表现形式，例如：</p>
<pre><code class="language-rust">for b in &quot;中国人&quot;.bytes() &#123;
    println!(&quot;&#123;&#125;&quot;, b);
&#125;
</code></pre>
<p>输出如下：</p>
<pre><code class="language-bash">228
184
173
229
155
189
228
186
186
</code></pre>
<p>如果想获取子串：考虑尝试下这个库：<a target="_blank" rel="noopener" href="https://crates.io/crates/utf8_slice">utf8_slice</a>。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的定义和分类"><a href="#数组的定义和分类" class="headerlink" title="数组的定义和分类"></a>数组的定义和分类</h3><p>数组的三要素：</p>
<ul>
<li>长度固定</li>
<li>元素必须有相同的类型</li>
<li>依次线性排列</li>
</ul>
<p>数组的分类：</p>
<ul>
<li>数组：array，速度快但是长度固定，数组属于基本类型（类比&amp;str）</li>
<li>动态数组：Vector，可动态增长，但是有性能损耗（类比String）</li>
</ul>
<p>从上述分类可以看出，array 和 &amp;str 属于基本类型，而 Vector 和 String 属于非基本类型，实际上，Vector 和 String 属于“集合类型”，较为复杂。</p>
<p><strong>本章节重点放在 array 上。</strong></p>
<h3 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h3><p>一般的创建：</p>
<pre><code class="language-rust">fn main() &#123;
    let a = [1, 2, 3, 4, 5];
    let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
&#125;
</code></pre>
<p>声明类型的数组：</p>
<pre><code class="language-rust">fn main() &#123;
    let a: [i32; 5] = [1, 2, 3, 4, 5];
&#125;
</code></pre>
<p>这里的 i32 是元素类型，5 是数组长度。</p>
<p>重复出现某值的数组：</p>
<pre><code class="language-rust">fn main() &#123;
    let a = [3; 5];
&#125;
</code></pre>
<p>a 数组包含 5 个元素，这些元素的初始化值为 3（这种语法跟数组类型的声明语法其实是保持一致的）</p>
<h3 id="数组元素的访问"><a href="#数组元素的访问" class="headerlink" title="数组元素的访问"></a>数组元素的访问</h3><pre><code class="language-rust">fn main() &#123;
    let a = [9, 8, 7, 6, 5];

    let first = a[0]; // 获取a数组第一个元素
    let second = a[1]; // 获取第二个元素
&#125;
</code></pre>
<p>索引下标是从 0 开始的</p>
<p>Rust语言不允许越界访问数组元素，一旦发生越界访问将会直接出现 panic。</p>
<h3 id="非基础类型的数组元素"><a href="#非基础类型的数组元素" class="headerlink" title="非基础类型的数组元素"></a>非基础类型的数组元素</h3><p>如果数组元素是非基本类型的，下列代码不被允许：</p>
<pre><code class="language-rust">let array = [String::from(&quot;rust is good!&quot;); 8];
println!(&quot;&#123;:#?&#125;&quot;, array);
</code></pre>
<p>原因：重复出现某值的数组的创建实质上是不断 Copy 实现的，而非基础类型不支持 Copy。</p>
<p>这里的 “{:#?}” 是一个功能强大的格式化占位符，它主要用于调试输出，并且会以更美观、易读的格式来展示数据。</p>
<p>正确的写法：</p>
<pre><code class="language-rust">let array = [String::from(&quot;rust is good!&quot;),String::from(&quot;rust is good!&quot;),String::from(&quot;rust is good!&quot;)];
println!(&quot;&#123;:#?&#125;&quot;, array);
/* 或者 */
let array: [String; 8] = std::array::from_fn(|_i| String::from(&quot;rust is good!&quot;));
println!(&quot;&#123;:#?&#125;&quot;, array);
</code></pre>
<p>输出结果为（看看”{:#?}”的功能）：</p>
<pre><code class="language-bash">[
    &quot;rust is good!&quot;,
    &quot;rust is good!&quot;,
    &quot;rust is good!&quot;,
    &quot;rust is good!&quot;,
    &quot;rust is good!&quot;,
    &quot;rust is good!&quot;,
    &quot;rust is good!&quot;,
    &quot;rust is good!&quot;,
]
</code></pre>
<p>from_fn 是标准库提供的一个函数，用于通过一个闭包（匿名函数）来动态生成数组的每个元素。它的核心价值在于，它为数组中的每个索引都调用一次这个闭包，从而创建全新的实例。这对于像 String这样没有实现 Copytrait 的类型至关重要，因为它避免了所有权问题。</p>
<p>闭包逻辑：|_i| String::from(“rust is good!”)</p>
<ul>
<li>这是传递给 from_fn 的闭包</li>
<li>|_i|：闭包接收一个参数 i（类型为 usize），代表当前元素的索引（从 0 到 7）。前面的下划线 _ 是一个约定，告诉 Rust 编译器我们有意不使用这个参数，以避免未使用变量的警告（见前文“变量的绑定与解构——未使用的变量”）</li>
<li>String::from(“rust is good!”)：闭包的主体。它每次被调用时都会执行一次，在堆上创建一个全新的、内容为 “rust is good!”的 String。由于每次调用都会创建一个新的 String，我们最终得到了 8 个独立的、所有权明确的字符串对象。</li>
</ul>
<h3 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h3><pre><code class="language-rust">let a: [i32; 5] = [1, 2, 3, 4, 5];
let slice: &amp;[i32] = &amp;a[1..3];
assert_eq!(slice, &amp;[2, 3]);
</code></pre>
<p>上面的数组切片 slice 的类型是&amp;[i32]，与之对比，数组的类型是[i32;5]</p>
<p>现在可以再看看切片的特点：<em>（ps：可以回到“复合类型——字符串与切片——切片”看看能否更好地理解切片的特点）</em></p>
<ul>
<li>切片的长度可以与数组不同，并不是固定的，而是取决于你使用时指定的起始和结束位置</li>
<li>创建切片的代价非常小，因为切片只是针对底层数组的一个引用</li>
<li>切片类型 [T] 拥有不固定的大小，而切片引用类型 &amp;[T] 则具有固定的大小，因为 Rust 很多时候都需要固定大小数据类型，因此 &amp;[T] 更有用，<code>&amp;str</code> 字符串切片也同理</li>
</ul>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><pre><code class="language-rust">fn main() &#123;
  // 编译器自动推导出one的类型
  let one             = [1, 2, 3];
  // 显式类型标注
  let two: [u8; 3]    = [1, 2, 3];
  let blank1          = [0; 3];
  let blank2: [u8; 3] = [0; 3];

  // arrays是一个二维数组，其中每一个元素都是一个数组，元素类型是[u8; 3]
  let arrays: [[u8; 3]; 4]  = [one, two, blank1, blank2];
&#125;
</code></pre>
<h3 id="数组的注意事项"><a href="#数组的注意事项" class="headerlink" title="数组的注意事项"></a>数组的注意事项</h3><p>数组虽然很简单，但是其实还是存在几个要注意的点：</p>
<ul>
<li>数组类型容易跟数组切片混淆，[T;n] 描述了一个数组的类型，而 [T] 描述了切片的类型， 因为切片是运行期的数据结构，它的长度无法在编译期得知，因此不能用 [T;n] 的形式去描述</li>
<li>[u8; 3]和[u8; 4]是不同的类型，数组的长度也是类型的一部分</li>
<li>在实际开发中，使用最多的是数组切片[T]，我们往往通过引用的方式去使用&amp;[T]，因为后者有固定的类型大小</li>
</ul>
<h1 id="复合类型（二）：元组、结构体和枚举"><a href="#复合类型（二）：元组、结构体和枚举" class="headerlink" title="复合类型（二）：元组、结构体和枚举"></a>复合类型（二）：元组、结构体和枚举</h1><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><h3 id="元组-1"><a href="#元组-1" class="headerlink" title="元组"></a>元组</h3><p>元组是多种类型组合一起形成的复合类型，长度和顺序都固定。</p>
<pre><code class="language-rust">fn main() &#123;
    let tup: (i32, f64, u8) = (500, 6.4, 1);
&#125;
</code></pre>
<pre><code class="language-rust">fn main() &#123;
    let tup = (500, 6.4, 1);
    let (x, y, z) = tup;
    println!(&quot;The value of y is: &#123;&#125;&quot;, y);
&#125;
</code></pre>
<p>这些都是合法的元组创建和绑定。</p>
<h3 id="元组访问与使用"><a href="#元组访问与使用" class="headerlink" title="元组访问与使用"></a>元组访问与使用</h3><p>访问某个元组的特定元素，使用<code>.</code>的访问方式：</p>
<pre><code class="language-rust">fn main() &#123;
    let x: (i32, f64, u8) = (500, 6.4, 1);
    let five_hundred = x.0;
    let six_point_four = x.1;
    let one = x.2;
&#125;
</code></pre>
<p>元组使用示例：</p>
<pre><code class="language-rust">fn main() &#123;
    let s1 = String::from(&quot;hello&quot;);
    let (s2, len) = calculate_length(s1);
    println!(&quot;The length of &#39;&#123;&#125;&#39; is &#123;&#125;.&quot;, s2, len);
&#125;
fn calculate_length(s: String) -&gt; (String, usize) &#123;
    let length = s.len(); // len() 返回字符串的长度
    (s, length)
&#125;
</code></pre>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="结构体创建"><a href="#结构体创建" class="headerlink" title="结构体创建"></a>结构体创建</h3><p>一个结构体由几部分组成：</p>
<ul>
<li>通过关键字 struct 定义</li>
<li>一个清晰明确的结构体：名称</li>
<li>几个有名字的结构体：字段</li>
</ul>
<p>例如：</p>
<pre><code class="language-rust">struct User &#123;
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
&#125;    // 结构体名称是 User，拥有 4 个字段，且每个字段都有对应的字段名及类型声明
fn main() &#123;
    let user1 = User &#123;
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    &#125;;
&#125;
</code></pre>
<p>注意：</p>
<ul>
<li>初始化实例时，每个字段都需要进行初始化</li>
<li>初始化时的字段顺序不需要和结构体定义时的顺序一致</li>
</ul>
<h3 id="结构体访问"><a href="#结构体访问" class="headerlink" title="结构体访问"></a>结构体访问</h3><p>通过 <code>.</code> 操作符即可访问结构体实例内部的字段值，也可以修改它们</p>
<pre><code class="language-rust">fn main() &#123;
    let mut user1 = User &#123;
        // 注意：只能是结构体可变，字段不能单独可变
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    &#125;;
    user1.email = String::from(&quot;anotheremail@example.com&quot;);
&#125;
</code></pre>
<h3 id="简化结构体创建"><a href="#简化结构体创建" class="headerlink" title="简化结构体创建"></a>简化结构体创建</h3><p>下面的函数类似一个构建函数，返回了 User 结构体的实例，两个函数等效：</p>
<pre><code class="language-rust">/* 1 */
fn build_user(email: String, username: String) -&gt; User &#123;
    User &#123;
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    &#125;
&#125;
/* 2 */
fn build_user(email: String, username: String) -&gt; User &#123;
    User &#123;
        email,
        username,
        active: true,
        sign_in_count: 1,
    &#125;
&#125;
</code></pre>
<h3 id="结构体更新语法"><a href="#结构体更新语法" class="headerlink" title="结构体更新语法"></a>结构体更新语法</h3><p>下面的函数根据已有的结构体实例，创建新的结构体实例，例如根据已有的 user1 实例来构建 user2，则两个语段等效：</p>
<pre><code class="language-rust">/* 1 */
let user2 = User &#123;
      active: user1.active,
      username: user1.username,
      email: String::from(&quot;another@example.com&quot;),
      sign_in_count: user1.sign_in_count,
&#125;;
/* 2 */
let user2 = User &#123;
      email: String::from(&quot;another@example.com&quot;),
      ..user1  // 凡是没有显示声明的，统统去 user1 获取
&#125;;
</code></pre>
<p>结构体更新语法跟赋值语句 &#x3D; 非常相像，因此在上面代码中，user1 的部分字段所有权被转移到 user2 中：username 字段发生了所有权转移，作为结果，user1 无法再被使用。</p>
<p>（注意，只有username是所有权转移，剩下两个从 user1 传过去的字段是 Copy 过去的）</p>
<h3 id="结构体的内存排列"><a href="#结构体的内存排列" class="headerlink" title="结构体的内存排列"></a>结构体的内存排列</h3><pre><code class="language-rust">#[derive(Debug)]
 struct File &#123;
   name: String,
   data: Vec&lt;u8&gt;,
 &#125;

 fn main() &#123;
   let f1 = File &#123;
     name: String::from(&quot;f1.txt&quot;),
     data: Vec::new(),
   &#125;;

   let f1_name = &amp;f1.name;
   let f1_length = &amp;f1.data.len();

   println!(&quot;&#123;:?&#125;&quot;, f1);
   println!(&quot;&#123;&#125; is &#123;&#125; bytes long&quot;, f1_name, f1_length);
 &#125;
</code></pre>
<p>其中的 <code>#[derive(Debug)]</code> 是让编译器为你定义的类型（例如结构体或枚举）自动实现 Debug 的属性（Attribute）。此时如果想输出结构体，可以使用 <code>&#123;:?&#125;</code>（不换行） 或 <code>&#123;:#?&#125;</code>（会换行）的形式打印出来。当然用宏 dbg! 也可以。</p>
<p>上面定义的 File 结构体在内存中的排列如下图所示：</p>
<p><img src="/img/Rust%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.assets/4.png"></p>
<p>从图中可以清晰地看出 File 结构体两个字段 name 和 data 分别拥有底层两个 [u8] 数组的所有权（String 类型的底层也是 [u8] 数组），通过 ptr 指针指向底层数组的内存地址，这里你可以把 ptr 指针理解为 Rust 中的引用类型。</p>
<p>该图片也侧面印证了：把结构体中具有所有权的字段转移出去后，将无法再访问该字段，但是可以正常访问其它的字段。</p>
<h3 id="元组结构体"><a href="#元组结构体" class="headerlink" title="元组结构体"></a>元组结构体</h3><pre><code class="language-rust">    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
</code></pre>
<p>元组结构体在你希望有一个整体名称，但是又不关心里面字段的名称时将非常有用。</p>
<h3 id="单元结构体"><a href="#单元结构体" class="headerlink" title="单元结构体"></a>单元结构体</h3><p>如果你定义一个类型，但是不关心该类型的内容，只关心它的行为时，就可以使用单元结构体：</p>
<pre><code class="language-rust">struct AlwaysEqual;
let subject = AlwaysEqual;
// 我们不关心 AlwaysEqual 的字段数据，只关心它的行为，因此将它声明为单元结构体，然后再为它实现某个特征
impl SomeTrait for AlwaysEqual &#123;

&#125;
</code></pre>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="枚举的语法"><a href="#枚举的语法" class="headerlink" title="枚举的语法"></a>枚举的语法</h3><p>以扑克牌花色为例：</p>
<ul>
<li><p>定义一个枚举类型：</p>
<pre><code class="language-rust">enum PokerSuit &#123;
  Clubs,
  Spades,
  Diamonds,
  Hearts,
&#125;
</code></pre>
<p>枚举类型是一个类型（PokerSuit），它会包含所有可能的枚举成员（Clubs、Spades、Diamonds、Hearts），而枚举值是该类型中的具体某个成员的实例。</p>
</li>
<li><p>枚举值：用 <code>::</code> 操作符来创建 PokerSuit 枚举类型的两个成员实例，</p>
<pre><code class="language-rust">let heart = PokerSuit::Hearts;
let diamond = PokerSuit::Diamonds;
</code></pre>
<p>定义一个函数使用它们：</p>
<pre><code class="language-rust">fn main() &#123;
    let heart = PokerSuit::Hearts;
    let diamond = PokerSuit::Diamonds;
    print_suit(heart);
    print_suit(diamond);
&#125;
fn print_suit(card: PokerSuit) &#123;
    // 需要在定义 enum PokerSuit 的上面添加上 #[derive(Debug)]，否则会报 card 没有实现 Debug
    println!(&quot;&#123;:?&#125;&quot;,card);
&#125;
</code></pre>
<p>print_suit 函数的参数类型是 PokerSuit，因此我们可以把 heart 和 diamond 传给它，虽然 heart 是基于 PokerSuit 下的 Hearts 成员实例化的，但是它是货真价实的 PokerSuit 枚举类型。</p>
</li>
<li><p>其他枚举的用法：</p>
<ul>
<li><p>以下两段代码都可以实现扑克牌花色和点数的联动：</p>
<pre><code class="language-rust">/* 1 */
enum PokerSuit &#123;
    Clubs,
    Spades,
    Diamonds,
    Hearts,
&#125;
struct PokerCard &#123;
    suit: PokerSuit,
    value: u8
&#125;
fn main() &#123;
   let c1 = PokerCard &#123;
       suit: PokerSuit::Clubs,
       value: 1,
   &#125;;
   let c2 = PokerCard &#123;
       suit: PokerSuit::Diamonds,
       value: 12,
   &#125;;
&#125;

/* 2 */
enum PokerCard &#123;  // 直接将数据信息关联到枚举成员上
    Clubs(u8),
    Spades(u8),
    Diamonds(u8),
    Hearts(u8),
&#125;
fn main() &#123;
   let c1 = PokerCard::Spades(5);
   let c2 = PokerCard::Diamonds(13);
&#125;
</code></pre>
</li>
<li><p>同一枚举类型下的不同成员可以持有不同数据类型：</p>
<pre><code class="language-rust">enum PokerCard &#123;
    Clubs(u8),
    Spades(u8),
    Diamonds(char),
    Hearts(char),
&#125;
fn main() &#123;
   let c1 = PokerCard::Spades(5);
   let c2 = PokerCard::Diamonds(&#39;A&#39;);
&#125;
</code></pre>
<p>甚至可以是字符串、数值、结构体甚至另一个枚举：</p>
<pre><code class="language-rust">enum Message &#123;
    Quit,                        // 没有任何关联数据
    Move &#123; x: i32, y: i32 &#125;,     // 包含一个匿名结构体
    Write(String),               // 包含一个 String 字符串
    ChangeColor(i32, i32, i32),  // 包含三个 i32
&#125;
fn main() &#123;
    let m1 = Message::Quit;
    let m2 = Message::Move&#123;x:1,y:1&#125;;
    let m3 = Message::ChangeColor(255,255,0);
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>由于每个结构体都有自己的类型，因此我们无法在需要同一类型的地方进行使用，例如某个函数它的功能是接受消息并进行发送，那么用枚举的方式，就可以接收不同的消息，但是用结构体，该函数无法接受 4 个不同的结构体作为参数。而且从代码规范角度来看，枚举的实现更简洁，代码内聚性更强，不像结构体的实现，分散在各个地方。</p>
</li>
</ul>
<h3 id="同一化类型"><a href="#同一化类型" class="headerlink" title="同一化类型"></a>同一化类型</h3><p>我们有一个这样的问题：</p>
<ul>
<li>有两种不同的网络流：<code>TcpStream</code> 和 <code>TlsStream&lt;TcpStream&gt;</code></li>
<li>我们希望用<strong>同一个函数</strong>处理这两种流</li>
<li>但它们是不同的类型，Rust的强类型系统不允许直接互换</li>
</ul>
<p>那么我们可以定义一个枚举类型：</p>
<pre><code class="language-rust">enum WebSocket &#123;
  Tcp(WebSocket&lt;TcpStream&gt;),
  Tls(WebSocket&lt;native_tls::TlsStream&lt;TcpStream&gt;&gt;),
&#125;
</code></pre>
<p>类型名称：WebSocket（实际上是WebSocket枚举）<br>两个变体：</p>
<ol>
<li>Tcp：包装普通的TCP WebSocket连接</li>
<li>Tls：包装TLS加密的WebSocket连接</li>
</ol>
<p>利用以下代码处理这两个连接：</p>
<pre><code class="language-rust">fn new (stream: TcpStream) &#123;
  let mut s = stream;
  if tls &#123;
    s = negotiate_tls(stream)
  &#125;

  // websocket是一个WebSocket&lt;TcpStream&gt;或者WebSocket&lt;native_tls::TlsStream&lt;TcpStream&gt;&gt;类型
  websocket = WebSocket::from_raw_socket(
    s, ......)
&#125;
</code></pre>
<h3 id="Option-枚举用于处理空值"><a href="#Option-枚举用于处理空值" class="headerlink" title="Option 枚举用于处理空值"></a>Option 枚举用于处理空值</h3><p>Rust 抛弃了 null，而改为使用 Option 枚举变量来表述当前时刻变量的值是缺失的这种结果。</p>
<p>Option 枚举包含两个成员，一个成员表示含有值：Some(T), 另一个表示没有值：None，定义如下：</p>
<pre><code class="language-rust">enum Option&lt;T&gt; &#123;
    Some(T),
    None,
&#125;
</code></pre>
<p>其中 T 是泛型参数，Some(T)表示该枚举成员的数据类型是 T，换句话说，Some 可以包含任何类型的数据。</p>
<p>Option 枚举以及 Some 和 None 都被包含在了 prelude（prelude 属于 Rust 标准库，Rust 会将最常用的类型、函数等提前引入其中，省得我们再手动引入）之中，不需要将其显式引入作用域，甚至不需要 Option:: 前缀就可直接使用 Some 和 None 。</p>
<pre><code class="language-rust">let some_number = Some(5);
let some_string = Some(&quot;a string&quot;);

let absent_number: Option&lt;i32&gt; = None;
</code></pre>
<p>如果使用 None 而不是 Some，需要告诉 Rust Option<T> 是什么类型的，因为编译器只通过 None 值无法推断出 Some 成员保存的值的类型。</p>
<p>Option的优势：</p>
<pre><code class="language-rust">let x: i8 = 5;           // 一定有值，编译器保证不为空
let y: Option&lt;i8&gt; = Some(5);  // 可能有值，可能为空

// 编译错误！不能直接相加
// let sum = x + y; 会报错！！
</code></pre>
<p>编译器强制你显式处理 None 情况：</p>
<pre><code class="language-rust">// match 是模式匹配知识，可以先理解为按顺序检查每个分支的模式，并执行第一个匹配成功的分支对应的代码。
let sum = match y &#123;
    Some(value) =&gt; x + value,  // 有值时才相加
    None =&gt; x,                 // 无值时如何处理
&#125;;
</code></pre>
<p>为了拥有一个可能为空的值，你必须要显式的将其放入对应类型的 <code>Option&lt;T&gt;</code> 中。接着，当使用这个值时，必须明确的处理值为空的情况。只要一个值不是 <code>Option&lt;T&gt;</code> 类型，你就 可以 安全的认定它的值不为空。这是 Rust 的一个经过深思熟虑的设计决策，来限制空值的泛滥以增加 Rust 代码的安全性。</p>
<hr>
<p><em><strong>本文章已完结，后续可能会有部分内容的修改和更新，以保证文章的正确性和逻辑严密性。如需要继续学习Rust基础知识请移步《Rust基础入门：续章》</strong></em></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://emotionaledm.github.io">EmotionalEDM</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://emotionaledm.github.io/2025/12/01/Rust%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/">http://emotionaledm.github.io/2025/12/01/Rust%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Rust/">Rust</a></div><div class="post-share"><div class="social-share" data-image="https://www.imageoss.com/images/2025/12/02/Illustration-178803c2c8d45f3227d5.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/12/11/MoeWeb1/" title="MoeCTF 2025 Web 入门第一弹（已完结）"><img class="cover" src="https://www.imageoss.com/images/2025/12/11/ifi_1080_basea32b8496c22057fb.jpg" onerror="onerror=null;src='https://www.imageoss.com/images/2025/12/02/Cover-Hd---aurora58ed563ed7ae0cae.png'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">MoeCTF 2025 Web 入门第一弹（已完结）</div></div><div class="info-2"><div class="info-item-1">本文为 MoeCTF 2025 Web 部分 1~10章题解，附两个 revenge 和一个番外，题目网站为：MoeCTF 2025 - 西电 CTF 终端 第一章、神秘的手镯知识点：F12开发者工具题目要求在所给框中填入已知的10000字密码，但是不让粘贴。 不准粘贴，那就开发者工具将10000字密码输入到该替换的地方就行。      第一章（sp）、神秘的手镯_revenge知识点：Burp Suite 的 Intruder 爆破功能，备份文件题目提到备份文件wanyanzhou.txt，所以访问&#x2F;wanyanzhou.txt.bak 下载该文件后，需要输入500次密码。 使用Burp Suite抓包得到以下信息：   在Burp Suite的Intruder模块进行爆破：   Moe笑传之猜猜爆知识点：控制台，代码审计题目说仅给一次机会猜数，那必须得先知道数再猜：  F12开发者工具，打开网络栏，发现有一份js代码，提取关键部分： function resetGame() &#123;   guessCount = 1;   const resetParas = ...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://www.imageoss.com/images/2025/08/31/_2025-08-31_154628_5697ba1eb627e156b0e.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">EmotionalEDM</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/EmotionalEDM"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">代码敲累了就打打音游吧~ 强烈推荐 Rizline 和 A Dance of Fire and Ice 哦~ 主页右上角有许多好玩的可以看看~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A%E4%B8%8E%E8%A7%A3%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">变量绑定与解构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D"><span class="toc-number">1.1.</span> <span class="toc-text">变量命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A"><span class="toc-number">1.2.</span> <span class="toc-text">变量绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">变量可变性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.</span> <span class="toc-text">未使用的变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%84"><span class="toc-number">1.5.</span> <span class="toc-text">变量解构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">1.6.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E9%81%AE%E8%94%BD"><span class="toc-number">1.7.</span> <span class="toc-text">变量遮蔽</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">数值类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.2.</span> <span class="toc-text">语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C%E5%80%9F%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">所有权和借用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">3.1.</span> <span class="toc-text">所有权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">3.2.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">3.3.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E5%8E%9F%E5%88%99"><span class="toc-number">3.4.</span> <span class="toc-text">所有权原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E8%AF%86String"><span class="toc-number">3.5.</span> <span class="toc-text">初识String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92"><span class="toc-number">3.6.</span> <span class="toc-text">变量绑定后的数据交互</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%A0%E5%80%BC%E4%B8%8E%E8%BF%94%E5%9B%9E"><span class="toc-number">3.7.</span> <span class="toc-text">函数的传值与返回</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%92%8C%E5%80%9F%E7%94%A8"><span class="toc-number">3.8.</span> <span class="toc-text">引用和借用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="toc-number">3.8.1.</span> <span class="toc-text">引用与解引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8"><span class="toc-number">3.8.2.</span> <span class="toc-text">不可变引用与可变引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%AC%E5%9E%82%E5%BC%95%E7%94%A8"><span class="toc-number">3.8.3.</span> <span class="toc-text">悬垂引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">4.</span> <span class="toc-text">复合类型（一）：字符串和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%88%87%E7%89%87"><span class="toc-number">4.1.</span> <span class="toc-text">字符串与切片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87"><span class="toc-number">4.1.1.</span> <span class="toc-text">切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.1.2.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.3.</span> <span class="toc-text">字符串操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B9%89"><span class="toc-number">4.1.4.</span> <span class="toc-text">字符串转义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C-UTF-8-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.1.5.</span> <span class="toc-text">操作 UTF-8 字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">4.2.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-number">4.2.1.</span> <span class="toc-text">数组的定义和分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">4.2.2.</span> <span class="toc-text">数组的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">4.2.3.</span> <span class="toc-text">数组元素的访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">4.2.4.</span> <span class="toc-text">非基础类型的数组元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87"><span class="toc-number">4.2.5.</span> <span class="toc-text">数组切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">4.2.6.</span> <span class="toc-text">二维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.2.7.</span> <span class="toc-text">数组的注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%85%83%E7%BB%84%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%9E%9A%E4%B8%BE"><span class="toc-number">5.</span> <span class="toc-text">复合类型（二）：元组、结构体和枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%BB%84"><span class="toc-number">5.1.</span> <span class="toc-text">元组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84-1"><span class="toc-number">5.1.1.</span> <span class="toc-text">元组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84%E8%AE%BF%E9%97%AE%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">5.1.2.</span> <span class="toc-text">元组访问与使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">5.2.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9B%E5%BB%BA"><span class="toc-number">5.2.1.</span> <span class="toc-text">结构体创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E8%AE%BF%E9%97%AE"><span class="toc-number">5.2.2.</span> <span class="toc-text">结构体访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9B%E5%BB%BA"><span class="toc-number">5.2.3.</span> <span class="toc-text">简化结构体创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%9B%B4%E6%96%B0%E8%AF%AD%E6%B3%95"><span class="toc-number">5.2.4.</span> <span class="toc-text">结构体更新语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E6%8E%92%E5%88%97"><span class="toc-number">5.2.5.</span> <span class="toc-text">结构体的内存排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">5.2.6.</span> <span class="toc-text">元组结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">5.2.7.</span> <span class="toc-text">单元结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">5.3.</span> <span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">5.3.1.</span> <span class="toc-text">枚举的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E4%B8%80%E5%8C%96%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.2.</span> <span class="toc-text">同一化类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Option-%E6%9E%9A%E4%B8%BE%E7%94%A8%E4%BA%8E%E5%A4%84%E7%90%86%E7%A9%BA%E5%80%BC"><span class="toc-number">5.3.3.</span> <span class="toc-text">Option 枚举用于处理空值</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/11/MoeWeb1/" title="MoeCTF 2025 Web 入门第一弹（已完结）"><img src="https://www.imageoss.com/images/2025/12/11/ifi_1080_basea32b8496c22057fb.jpg" onerror="this.onerror=null;this.src='https://www.imageoss.com/images/2025/12/02/Cover-Hd---aurora58ed563ed7ae0cae.png'" alt="MoeCTF 2025 Web 入门第一弹（已完结）"/></a><div class="content"><a class="title" href="/2025/12/11/MoeWeb1/" title="MoeCTF 2025 Web 入门第一弹（已完结）">MoeCTF 2025 Web 入门第一弹（已完结）</a><time datetime="2025-12-10T16:00:00.000Z" title="Created 2025-12-11 00:00:00">2025-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/01/Rust%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/" title="Rust 基础入门（已完结）"><img src="https://www.imageoss.com/images/2025/12/02/Illustration-178803c2c8d45f3227d5.png" onerror="this.onerror=null;this.src='https://www.imageoss.com/images/2025/12/02/Cover-Hd---aurora58ed563ed7ae0cae.png'" alt="Rust 基础入门（已完结）"/></a><div class="content"><a class="title" href="/2025/12/01/Rust%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/" title="Rust 基础入门（已完结）">Rust 基础入门（已完结）</a><time datetime="2025-11-30T16:00:00.000Z" title="Created 2025-12-01 00:00:00">2025-12-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://www.imageoss.com/images/2025/12/02/Illustration-178803c2c8d45f3227d5.png);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By EmotionalEDM</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>